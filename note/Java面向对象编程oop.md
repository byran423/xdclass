# Java面向对象编程oop

***

## 构造函数和封装

什么是构造函数

* 一种特殊的方法
* 创建对象时，用来初始化对象，每次使用new创建对象 的时候，就会使用构造函数
* 与类具有相同的名称，但是没有返回值
* Java会自动为每一个类提供一个默认构造函数
* 如果自己定义了构造函数，就不再使用默认构造函数

构造函数种类

* 默认构造函数

```
public 类名(){

}
```

* 无参构造函数

```utf-8
public 类名(){
    //写自定义的语句
}
```

* 有参构造函数

```
public 类名(参数类型1 参数名1,参数类型2 参数名2,...){
    //自定义方法体
}
```

构造函数修饰符

* public用的最多，用来创建对象  
* private私有化构造函数，不给外部创建对象，比如工具类或者单例设计模式
* default 默认，用的少

什么是封装

* 封装是把过程和数据包围起来，对数据的访问只能通过已定义的接口即方法
* 在Java中通过关键字private、protected、public实现封装
* 什么是封装？封装把对象的所有组成部分组合在一起，封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据程度。适当的封装可以让代码更容易理解和维护，也增强了代码的安全性

overload（重载、过载）

* 在一个类里面，方法和名字相同，而参数不同，和返回类型无关

override （重写、覆盖）

* 子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变
  
  * 返回值类型，方法名，参数类型及个数
* 子类能够根据需要实现父类的方法

### this 关键字

* 当一个对象创建后，JVM会给这个对象分配一个引用自身的指针，这个指针的名字就是this
* 只能用于非静态方法体内，静态方法和代码块不能出现this
* this就是指向当前对象本身

### 继承

格式：通过extend关键字

```
Class 父类名称{

}
Class 子类名称 extend 父类名称 {

}
```

特点

* 子类拥有父类的非private的属性和方法
* 子类可以用自己的方式实现父类的方法 override（重写、覆盖）
* 实现了代码的复用
* 重写从父类那里继承来的方法，当调用方法时会优先调用子类的方法(默认就近原则)

注意：

* 不支持多继承，支持多重继承，多重继承提高了耦合性，组合优于继承
* 所有的类都是继承于 java.lang.Object
* final关键字
  
  * 修饰的类，则这个类不可以被继承
  * 修饰方法，则这个方法不允许被覆盖（重写）

### super关键字

*this() 和super ()都是指的对象，均不可以在static环境中使用*

* 包括：static变量，  static方法，static语句块

*构造函数super和this*

* this和super在构造函数中只能有一个且都必须是构造函数当中的第一行
* 当父类的构造函数是无参构造函数时，在子类的构造函数中，不用显式super()去调用父类的构造函数
* 当父类的构造函数是有参的构造函数时，如果子类的构造函数中不写super()进行调用父类的构造函数，编译器会报错

**Java继承后类的初始化顺序**

* 静态代码块，非静态代码块，父类/子类无参构造方法，父类/子类一般方法
  
  * 父类静态代码块-》子类静态代码块-》父类无参构造函数-》子类无参构造函数-》父类一般方法-》子类一般方法



### 面向对象之抽象

**什么是抽象**

* 当父类的某些方法不确定时，可以用abstract关键字来修饰该方法，即抽象方法，用abstract来修饰该类，即抽象类
  
  ```
  //抽象类
  abstract class 类名{
  }
  //抽象方法，不能有方法主题
  abstract 返回类型 方法名();
  ```

*抽象方法的特点*

* 抽象类中的抽象方法只是声明，不包含方法体
* 抽象方法不能用private修饰，因为抽象方法必须被子类实现（重写），而private权限对于子类来说是不能访问的
* 一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类
* 构造方法，类方法（即static修饰的方法）不能声明为抽象方法。



### 接口

**什么是接口**

* 是抽象方法的集合，接口通常以interface来声明，一个类通过继承接口的方式，从而继承接口的抽象方法
* 语法
  
  ```
  interface 名称 [extends 其它接口名]{
      //声明变量
      //声明方法
  }
  ```

接口的特点

* 接口的方法都是抽象方法，默认都是public abstract，其它修饰符都会报错
* 接口中可以含有变量，但是接口中的变量会被隐式的指定为**public static final**
* 类描述对象的属性和方法，而接口则包含要实现的方法
* 接口无法被实例化，需要被实现才行
* 一个实现接口的类，必须实现接口内描述的所有方法，否则就必须声明为抽象类

接口和类的区别

* 接口中没有构造函数
* 接口里可以有静态方法和方法体
* 接口中所有方法必须是抽象方法（JDK8之后就不是）
* 接口不是被类继承了，而是要被类实现
* 支持多继承，类不支持多个类继承

*接口的实现*

* 当类实现接口的时候，类要实现接口中所有的方法，不然类必须声明为抽象类，使用implements关键字实现所有接口
* 语法
  
  ```
  class 类名 implements 接口名称[,其它接口名称]{
      //要实现的方法
  }
  ```

**注意**

* 一个类只能继承一个类，但是能实现多个接口
* 接口能继承另一个接口，接口的继承使用extends关键字，和类继承一样

JDK8新特性

*    interface中可以有static方法，但必须有方法实现体，该方法只属于该接口，接口名直接调用该方法
* 接口中新增default关键字修饰的方法，default方法只能定义在接口中，可以在子类或子接口中被重写，default定义的方法必须有方法体



### instanceOf关键字和多态

instanceOf关键字

* 是一个Java二元操作符（运算符）也是Java的保留关键字
* 作用
  
  * 判断一个类是否实现了某个接口，或者判断一个实例对象是否属于一个类
  * 语法
    
    ```
    boolean result = object instanceof class
    ```

总结：

* override是在不同类之前的行为，overload是在同一个类中的行为
* 多态
  
  * 同一个行为具有多个不同表现形式或形态的能力
  * 常见的形式
    
    * 继承方法的重写
    * 同类方法重载
    * 抽象方法
    * 接口
    
    
